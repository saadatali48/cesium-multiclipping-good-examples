<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
        />
        <title>通视分析</title>
        <style>
            @import url(../../Build/Cesium/Widgets/widgets.css);
            html,
            body,
            #cesiumContainer {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
                background-color: #000000;
            }
        </style>
    </head>

    <body>
        <div id="cesiumContainer"></div>
        <script type="module">
            /* eslint-disable */
            window.CESIUM_BASE_URL = '../../Source';
            import * as Cesium from '../../Source/Cesium.js';

            // 初始化容器
            var viewer = new Cesium.Viewer('cesiumContainer', {
                animation: false,
                baseLayerPicker: false,
                geocoder: false,
                timeline: false,
                infobox: false,
                navigationHelpButton: false,
                sceneModePicker: false,
                scene3DOnly: true,
                homeButton: false,
                infoBox: false,
                selectionIndicator: false,
                fullscreenButton: false,
                imageryProvider: new Cesium.UrlTemplateImageryProvider({
                    url:
                        'http://www.google.cn/maps/vt?lyrs=s@716&x={x}&y={y}&z={z}'
                })
            });

            // 开启地形深度监测
            viewer.scene.globe.depthTestAgainstTerrain = true;

            // 加载3dtile模型
            var tileset = new Cesium.Cesium3DTileset({
                url: 'http://localhost:8082/compare_with_glb/tileset.json'
            });
            viewer.scene.primitives.add(tileset);
            _changeModelPosition(tileset, 0, 0, 200);

            // entity集合
            var parentEntity = viewer.entities.add(new Cesium.Entity());

            // 视域点
            var viewPoint = Cesium.Cartesian3.fromDegrees(
                116.895407,
                36.652209,
                170
            ); // (自己的经纬度)

            var viewPointEntity = viewer.entities.add({
                parent: parentEntity,
                position: viewPoint,
                ellipsoid: {
                    radii: new Cesium.Cartesian3(0.1, 0.1, 0.1),
                    material: Cesium.Color.GREEN
                }
            });

            // 加载坐标轴,便于测试
            var transform = Cesium.Transforms.eastNorthUpToFixedFrame(
                viewPoint
            );
            var modelMatrixPrimitive = viewer.scene.primitives.add(
                new Cesium.DebugModelMatrixPrimitive({
                    modelMatrix: transform,
                    length: 1000.0
                })
            );

            // 世界坐标转换为投影坐标
            var webMercatorProjection = new Cesium.WebMercatorProjection(
                viewer.scene.globe.ellipsoid
            );
            var viewPointWebMercator = webMercatorProjection.project(
                Cesium.Cartographic.fromCartesian(viewPoint)
            );

            // 排除碰撞监测的对象
            var objectsToExclude = [viewPointEntity, modelMatrixPrimitive];

            // 目标点集合
            var destPoints = [];

            // 视域点和目标点的距离
            var radius = 1000; // 视距1000米

            // 计算一圈
            for (var i = 180; i <= 360; i++) {
                // 度数转弧度
                var radians = Cesium.Math.toRadians(i);
                // 计算目标点
                // 位于xy平面
                // var toPoint = new Cesium.Cartesian3(
                //   viewPointWebMercator.x + radius * Math.cos(radians),
                //   viewPointWebMercator.y + radius * Math.sin(radians),
                //   30
                // );
                // 位于xz平面
                var toPoint = new Cesium.Cartesian3(
                    viewPointWebMercator.x + radius * Math.cos(radians),
                    viewPointWebMercator.y,
                    170 + radius * Math.sin(radians)
                );
                // 投影坐标转世界坐标
                toPoint = webMercatorProjection.unproject(toPoint);
                destPoints.push(
                    Cesium.Cartographic.toCartesian(toPoint.clone())
                );

                // 添加排除的辅助对象
                objectsToExclude.push(
                    viewer.entities.add({
                        parent: parentEntity,
                        name: i,
                        position: Cesium.Cartesian3.fromDegrees(
                            Cesium.Math.toDegrees(toPoint.longitude),
                            Cesium.Math.toDegrees(toPoint.latitude),
                            toPoint.height
                        ),
                        ellipsoid: {
                            radii: new Cesium.Cartesian3(5, 5, 5),
                            material: Cesium.Color.RED
                        }
                    })
                );
            }

            // 绘制线
            function drawLine(leftPoint, secPoint, color) {
                viewer.entities.add({
                    polyline: {
                        positions: [leftPoint, secPoint],
                        arcType: Cesium.ArcType.NONE,
                        width: 5,
                        material: color,
                        depthFailMaterial: color
                    }
                });
            }

            function pickFromRay() {
                for (var i = 0; i < destPoints.length; i++) {
                    // 计算射线的方向，目标点left 视域点right
                    var direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(
                            destPoints[i],
                            viewPoint,
                            new Cesium.Cartesian3()
                        ),
                        new Cesium.Cartesian3()
                    );
                    // 建立射线
                    var ray = new Cesium.Ray(viewPoint, direction);
                    var result = viewer.scene.pickFromRay(
                        ray,
                        objectsToExclude
                    ); // 计算交互点，返回第一个
                    showIntersection(result, destPoints[i], viewPoint);
                }
            }

            // 处理交互点
            function showIntersection(result, destPoint, viewPoint) {
                // 如果是场景模型的交互点，排除交互点是地球表面
                if (Cesium.defined(result) && Cesium.defined(result.object)) {
                    drawLine(
                        result.position,
                        viewPoint,
                        new Cesium.Color(0, 1, 0, 0.5)
                    ); // 可视区域
                    drawLine(
                        result.position,
                        destPoint,
                        new Cesium.Color(1, 0, 0, 0.5)
                    ); // 不可视区域
                } else {
                    drawLine(viewPoint, destPoint, Cesium.Color.GREEN);
                }
            }

            function _changeModelPosition(tileset, lng, lat, height, adjust) {
                tileset.readyPromise.then(function(argument) {
                    var mat = Cesium.Matrix4.fromArray(tileset._root.transform);
                    var pos = Cesium.Matrix4.getTranslation(
                        mat,
                        new Cesium.Cartesian3()
                    );
                    var wpos = Cesium.Cartographic.fromCartesian(pos);
                    if (wpos) {
                        lng = Cesium.Math.toDegrees(wpos.longitude);
                        lat = Cesium.Math.toDegrees(wpos.latitude);
                        if (adjust) height = wpos.height + height;
                        else height = wpos.height + height + 0;
                    }

                    // var position = _originCamera.position;
                    var position = Cesium.Cartesian3.fromDegrees(
                        lng,
                        lat,
                        height
                    );
                    // var position = Cesium.Cartesian3.fromDegrees(
                    //   _originXY.lng,
                    //   _originXY.lat,
                    //   _originXY.height
                    // );
                    var mat = Cesium.Transforms.eastNorthUpToFixedFrame(
                        position
                    );
                    var rotationZZ = Cesium.Matrix4.fromRotationTranslation(
                        Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(0))
                    );
                    Cesium.Matrix4.multiply(mat, rotationZZ, mat);
                    tileset._root.transform = mat;
                    viewer.camera.flyToBoundingSphere(tileset.boundingSphere);

                    var timer = setTimeout(() => {
                        clearTimeout(timer);
                        pickFromRay();
                    }, 2000);
                });
            }
        </script>
    </body>
</html>
